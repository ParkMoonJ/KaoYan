# 《数据结构》综合应用题

## [2021 - 41]

已知无向连通图 $G$ 由顶点集 $V$ 和边集 $E$ 组成，$|E| > 0$，当 $G$ 中度为奇数的顶点个数为不大于 2 的偶数时，$G$ 存在包含所有边且长度为 $|E|$ 的路径（称为 EL 路径）。设图 $G$ 采用邻接矩阵存储，类型定义如下：

```cpp
typedef struct{ // 图的定义
    int numVertices, numEdges; // 图中实际的顶点数和边数
    char VerticesList[MAXV]; // 顶点表。MAXV 为已定义常量
    int Edge[MAXV][MAXV]; // 邻接矩阵
}MGraph;
```

请设计算法 `int IsExistEL(MGraph G)`，判断 $G$ 是否存在 EL 路径，若存在，则返回 1，否则返回 0。要求：

1. 给出算法的基本设计思想。
2. 根据设计思想，采用 C 或 C++ 语言描述算法，关键之处给出注释。
3. 说明你所设计算法的时间复杂度和空间复杂度。

---

```cpp
// 计数度为奇数的顶点个数，若为 0 或 2 则返回 1，否则返回 0。

int IsExistEL(MGraph G){
    int degree, i, j, count = 0;
    for (i = 0; i < G.numVertices; i++){
        degree = 0;
        for (j = 0; j < G.numVertices; j++){
            degree += G.Edge[i][j];
        }
        if (degree % 2 != 0) count++;
    }
    if (count = 0 || count = 2) return 1;
    else return 0;
}

// 时间复杂度：O(n^2)，
// 空间复杂度：O(1)。
```

## [2021 - 42]

已知某排序算法如下：

```c
void cmpCountSort(int a[], int b[], int n){
    int i, j, *count;
    count = (int *) malloc (sizeof(int) * n); // C++ 语言：count = new int[n];
    for (i = 0; i < n; i++) count[i] = 0;
    for (i = 0; i < n - 1; i++)
        for (j = i + 1; j < n; j++)
            if(a[i] < a[j]) count[j]++;
            else count[i]++;
        for (i = 0; i < n; i++) b[count[i]] = a[i];
        free(count); // C++ 语言：delete count;
}
```

请回答下列问题：

1. 若有 `int a[] = {25, -10, 25, 10, 11, 19}, b[6];`，则调用 `cmpCountSort(a, b, 6)` 后数组 `b` 中的内容是什么？
2. 若 `a` 中含有 $n$ 个元素，则算法执行过程中，元素之间的比较次数是多少？
3. 该算法是稳定的吗？若是，则阐述理由；否则，修改为稳定排序算法。

---

1. `b[] = (-10, 10, 11, 19, 25, 25)`
2. $\frac{n * (n - 1)}{2}$
3. 不是，不能保证两元素相同时，先出现的元素在前，应改为 `if (a[i] <= a[j]) count[j]++;`

## [2020 - 41]

定义三元组 $(a, b, c)$（其中 $a, b, c$ 均为正数）的距离 $D = |a - b| + |b - c| + |c - a|$。给定 3 个非空整数集合 $S_1$、$S_2$ 和 $S_3$，按升序分别存储在 3 个数组中。设计一个尽可能高效的算法，计算并输出所有可能的三元组 $(a, b, c) (a \in S_1, b \in S_2, c \in S_3)$ 中的最小距离。例如 $S_1 = \{-1, 0, 9\}, S_2 = \{-25, -10, 10, 11\}, S_3 = \{2, 9, 17, 30, 41\}$，则最小距离为 2，相应的三元组为 $\{9, 10, 9\}$。要求：

1. 给出算法的基本设计思想。
2. 根据设计思想，采用 C 或 C++ 语言描述算法，关键之处给出注释。
3. 说明你所设计算法的时间复杂度和空间复杂度。

---

不妨设 a <= b <= c，不难看出 D 的大小关键是 a 和 c 之间的距离，于是问题就可以简化为每次固定 c 找一个 a 使得 L3。

```cpp
#define INT_MAX 0x7fffffff

int Abs(int a){ // 计算绝对值
    if (a < 0) return -a;
    else return a;
}

bool IsMin(int a, int b, int c){ // a 是否是三个数中最小值
    if (a <= b && a <= c) return true;
    else return false;
}

int Ans(int a[], int la, int b[], int lb, int c[], int lc){
    int i = 0, j = 0, k = 0, D_min = INT_MAX, D; // D_min 用于记录三元组最小距离，初始赋为 INT_MAX
    while (i < la && j < lb && k < lc && D > 0){
        D = Abs(a[i] - b[j]) + Abs(b[j] - c[k]) + Abs(c[k] - a[i]); // 计算 D
        if (D < D_min) D_min = D; // 更新 D
        if (IsMin(a[i], b[j], c[k])) i++; // 更新 a
        else if(IsMin(b[j], a[i], c[k])) j++;
        else k++;
    }
    return D_min;
}
```

时间复杂度：$O(n)$  
空间复杂度：$O(1)$