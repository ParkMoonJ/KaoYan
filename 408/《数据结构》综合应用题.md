# 《数据结构》综合应用题

## 【2021 - 41】

已知无向连通图 $G$ 由顶点集 $V$ 和边集 $E$ 组成，$|E| > 0$，当 $G$ 中度为奇数的顶点个数为不大于 2 的偶数时，$G$ 存在包含所有边且长度为 $|E|$ 的路径（称为 EL 路径）。设图 $G$ 采用邻接矩阵存储，类型定义如下：

```cpp
typedef struct{ // 图的定义
    int numVertices, numEdges; // 图中实际的顶点数和边数
    char VerticesList[MAXV]; // 顶点表。MAXV 为已定义常量
    int Edge[MAXV][MAXV]; // 邻接矩阵
}MGraph;
```

请设计算法 `int IsExistEL(MGraph G)`，判断 $G$ 是否存在 EL 路径，若存在，则返回 1，否则返回 0。要求：

1. 给出算法的基本设计思想。
2. 根据设计思想，采用 C 或 C++ 语言描述算法，关键之处给出注释。
3. 说明你所设计算法的时间复杂度和空间复杂度。

---

```cpp
// 计数度为奇数的顶点个数，若为 0 或 2 则返回 1，否则返回 0。

int IsExistEL(MGraph G){
    int degree, i, j, count = 0;
    for (i = 0; i < G.numVertices; i++){
        degree = 0;
        for (j = 0; j < G.numVertices; j++){
            degree += G.Edge[i][j];
        }
        if (degree % 2 != 0) count++;
    }
    if (count = 0 || count = 2) return 1;
    else return 0;
}

// 时间复杂度：O(n^2)，
// 空间复杂度：O(1)。
```

## 【2021 - 42】

已知某排序算法如下：

```c
void cmpCountSort(int a[], int b[], int n){
    int i, j, *count;
    count = (int *) malloc (sizeof(int) * n); // C++ 语言：count = new int[n];
    for (i = 0; i < n; i++) count[i] = 0;
    for (i = 0; i < n - 1; i++)
        for (j = i + 1; j < n; j++)
            if(a[i] < a[j]) count[j]++;
            else count[i]++;
        for (i = 0; i < n; i++) b[count[i]] = a[i];
        free(count); // C++ 语言：delete count;
}
```

请回答下列问题：

1. 若有 `int a[] = {25, -10, 25, 10, 11, 19}, b[6];`，则调用 `cmpCountSort(a, b, 6)` 后数组 `b` 中的内容是什么？
2. 若 `a` 中含有 $n$ 个元素，则算法执行过程中，元素之间的比较次数是多少？
3. 该算法是稳定的吗？若是，则阐述理由；否则，修改为稳定排序算法。

---

1. `b[] = (-10, 10, 11, 19, 25, 25)`
2. $\frac{n * (n - 1)}{2}$
3. 不是，不能保证两元素相同时，先出现的元素在前，应改为 `if (a[i] <= a[j]) count[j]++;`

## 【2020 - 41】

定义三元组 $(a, b, c)$（其中 $a, b, c$ 均为正数）的距离 $D = |a - b| + |b - c| + |c - a|$。给定 3 个非空整数集合 $S_1$、$S_2$ 和 $S_3$，按升序分别存储在 3 个数组中。设计一个尽可能高效的算法，计算并输出所有可能的三元组 $(a, b, c) (a \in S_1, b \in S_2, c \in S_3)$ 中的最小距离。例如 $S_1 = \{-1, 0, 9\}, S_2 = \{-25, -10, 10, 11\}, S_3 = \{2, 9, 17, 30, 41\}$，则最小距离为 2，相应的三元组为 $\{9, 10, 9\}$。要求：

1. 给出算法的基本设计思想。
2. 根据设计思想，采用 C 或 C++ 语言描述算法，关键之处给出注释。
3. 说明你所设计算法的时间复杂度和空间复杂度。

---

不妨设 a <= b <= c，不难看出 D 的大小关键是 a 和 c 之间的距离，于是问题就可以简化为每次固定 c 找一个 a 使得 L3。

```cpp
#define INT_MAX 0x7fffffff

int Abs(int a){ // 计算绝对值
    if (a < 0) return -a;
    else return a;
}

bool IsMin(int a, int b, int c){ // a 是否是三个数中最小值
    if (a <= b && a <= c) return true;
    else return false;
}

int Ans(int a[], int la, int b[], int lb, int c[], int lc){
    int i = 0, j = 0, k = 0, D_min = INT_MAX, D; // D_min 用于记录三元组最小距离，初始赋为 INT_MAX
    while (i < la && j < lb && k < lc && D > 0){
        D = Abs(a[i] - b[j]) + Abs(b[j] - c[k]) + Abs(c[k] - a[i]); // 计算 D
        if (D < D_min) D_min = D; // 更新 D
        if (IsMin(a[i], b[j], c[k])) i++; // 更新 a
        else if(IsMin(b[j], a[i], c[k])) j++;
        else k++;
    }
    return D_min;
}
```

时间复杂度：$O(n)$  
空间复杂度：$O(1)$

---

## 【2020 - 42】

若任一个字符的编码都不是其他字符编码的前缀，则称这种编码具有前缀特性。现有某字符集（字符个数 >= 2）的不等长编码，每个字符的编码均为二进制的 0、1 序列，最长为 $L$ 位，且具有前缀特性。请回答下列问题：

1. 那种数据结构适宜保存上述具有前缀特性的不等长编码？
2. 基于你所设计的数据结构，简述从 0/1 串到字符串的译码过程。
3. 简述判定某字符集的不等长编码是否具有前缀特性的过程。

---

1. 使用一棵二叉树保存字符集中各字符的编码，每个编码对应于从根开始到达某叶结点的一条路径，路径长度等于编码位数，路径到达的叶结点中保存该编码对应的字符。
2. 从左至右依次扫描 0/1 串中的各位。从根开始，根据串中当前位沿当前节点的左子指针或右子指针下移，直到移动到叶结点为止。输出叶结点中保存的字符。然后从根开始重复这个过程，直到扫描到 0/1 串结束，译码完成。
3. 二叉树即可用于保存各字符的编码，又可用于检测编码是否具有前缀特性。判定编码是否具有前缀特性的过程，也是构建二叉树的进程。初始时，二叉树中仅含有根结点，其左子指针和右子指针均为空。

依次读入每个编码 C，建立/寻找从根开始对应于该编码的一条路径，过程如下：  
对每个编码，从左至右扫描 C 的各位，根据 C 的当前位（0 或 1）沿结点的指针（左子指针或右子指针）向下移动。当遇到空指针时，创建新结点，让空指针指向该新结点并继续移动。沿指针移动的过程中，可能遇到三种情况：

- 若遇到了叶结点（非根），则表明不具有前缀特性，返回。
- 若在处理 C 的所有位过程中，均没有创建新结点，则表明不具有前缀特性，返回。
- 若在处理 C 的最后一个编码位时创建了新结点，则继续验证下一个编码。

若所有编码均通过验证，则编码具有前缀特性。

## 【2019 - 41】

设线性表 $L = (a_!, a_2, a_3, \cdots, a_{n - 2}, a_{n - 1}, a_n)$ 采用带头结点的单链表保存，链表中的结点定义如下：

```c
typedef struct node{
    int data;
    struct node *next;
}NODE;
```

请设计一个空间复杂度为 $O(1)$ 且时间上尽可能高效的算法，重新排列 $L$ 中的各结点，得到线性表 $L' = (a_1, a_n, a_2, a_{n-1}, a_3, a_{n - 2}, \cdots)$。要求：

1. 给出算法的基本设计思想。
2. 根据设计思想，采用 C 或 C++ 语言描述算法，关键之处给出注释。
3. 说明你所设计算法的时间复杂度。

---

```cpp
void Ans(NODE *head){
    NODE *p, *q, *r, *s;
    // 寻找中间结点
    p = q = head;
    while (p->next) {
        p = p->next; // p 走一步
        q = q->next;
        if (q->next) q = q->next; // q 走两步
    }
    q = p->next;
    p->next = NULL; // p 为中间结点，q 为后半段链表的首结点
    // 将链表后半段逆置
    while (q) {
        r = q->next;
        q->next = p->next;
        p->next = q;
        q = r;
    }
    // 建立新链表 L’
    s = h->next;
    q = p->next;
    p->next = NULL;
    while(q) {
        r = q->next;
        q->next = s->next;
        s->next = q;
        s = q->next;
        q = r
    }
}
```

时间复杂度：$O(n)$。

## 【2019 - 42】

请设计一个队列，要求满足：

- 初始时对列为空；
- 入队时，允许增加队列占用空间；
- 出队后，出队元素所占用的空间可重复使用，即整个队列所占用的空间只增不减；
- 入队操作和出队操作的时间复杂度始终保持为 $O(1)$。

请回答下列问题：

1. 该队列是应选择链式存储结构，还是应选择顺序存储结构？
2. 画出该队列的初始状态，并给出判断队空和队满的条件。
3. 画出第一个元素入队后的队列状态。
4. 给出入队操作和出队操作的基本过程。

---

1. 顺序存储无法满足要求②的队列占用空间随着入队操作而增加。根据要求来分析：要求①容易满足：链式存储方便开辟新空间，要求②容易满足：对于要求，出队后的结点并不真正释放，用队头指针指向新的队头结点，新元素入队时，有空余结点则无须开辟新空间，赋值到队尾后的第一个空结点即可，然后用队尾指针指向新的队尾结点，这就需要设计成一个首尾相接的循环单链表，类似于循环队列的思想。设置队头、因此，采用链式存储结构（两段式单向循环链表），队头指针为 `front`，队尾指针为 `rear`。队尾指针后，链式队列的入队操作和出队操作的时间复杂度均为 $O(1)$），要求④可满足。
2. 该循环链式队列的实现，可以参考循环队列，不同之处在于循环链式队列可以方便增加空间，出队的结点可以循环利用，入队时空间不够也可以动态增加。同样，循环链式队列也要区分队满和队空的情况，这里参考循环队列牺牲一个单元来判断。初始时，创建只有一个空闲结点的循环单链表，头指针 `front` 和尾指针 `rear` 均指向空闲结点，如下图所示。  
队空的判定条件：`front == rear`。  
队满的判定条件：`front == rear->next`。
1. 插入第一个元素后的状态如下图所示。
2. 操作的基本过程如下：

```cpp
//入队操作
if (front == rear->next){ // 队满
    // 则在rear后面插入一个新的空闲结点；
    // 入队元素保存到rear所指结点中;
    rear = rear->next;
}
return;
//出队操作
if (front == rear) {// 队空
    // 则出队失败
    return;
}
// 取 front 所指结点中的元素 e;
front = front->next;
return e;
```

## 【2018 - 41】

给定一个含 $n (n \ge 1)$ 个整数的数组，请设计一个在时间上尽可能高效的算法，找出数组中未出现的最小正整数。例如，数组 $\{-5, 3, 2, 3\}$ 中未出现的最小正整数是 1；数组 $\{1, 2, 3\}$ 中未出现的最小正整数是 4.要求：

1. 给出算法的基本设计思想。
2. 根据设计思想，采用 C 或 C++ 语言描述算法，关键之处给出注释。
3. 说明你所设计算法的时间复杂度和空间复杂度。

建立新数组代表正整数 1 ~ n，当原数组中出现相应正整数时将相应位置标记为 1，最终输出第一个为 0 的位置代表的正整数。

```cpp
int Ans(int a[],int n){
    int temp[n];
    for (i = 0; i < n; i++)
        if (a[i] > 0 && a[i] <= n)
            b[i - 1] = 1;
    for (i = 0; i < n; i++)
        if (b[i] == 0) break;
    return i + 1;
}
```

时间复杂度：$O(n)$
空间复杂度：$O(n)$